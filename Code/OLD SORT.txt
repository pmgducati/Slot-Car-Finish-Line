// set the lane order array to all -1  (meaning, unsorted)
  for (int j = 0; j < 4; j++) {
    lane_order[j] = -1;
  }


  // each lane will get marked with a place, starting with 1st place
  int place = 1;

  // start at the current lap number going down to zero.
  // this may get slow at high lap numbers but should be fine as long as it doesnt get into the thousands of laps
  for (int i = Current_Lap_Num; i >= 0; i--) {
    // look at each lane, if they are on the current lap...
    // set the corresponding lane_order to 0 (meaning, to do)
    for (int j = 0; j < 4; j++) {
      if ( LapCounter[j] == i) {
        lane_order[j] = 0;
      }
    }


    // we want this to be the biggest time possible.
    unsigned long fastest = 0xFFFFFFFF;

    // of the lanes marked with a zero, what is the fastest time?
    for (int j = 0; j < 4; j++) {
      if ( lane_order[i] == 0) {
        fastest = min(fastest, LaneCurrentLap[j]);
	//fastest = min(fastest, RacePosition[j]);
      }
    }

    // which lane matches the fastest time?
    for (int j = 0; j < 4; j++) {
      if ( lane_order[j] == 0 && LaneCurrentLap[j] == fastest ) {
      //if ( lane_order[j] == 0 && RacePosition[j] == fastest ) {
        lane_order[j] = place;
        place++;
        break;
      }
      //Serial.println (" ");
    }

    // reset unsorted items
    for (int j = 0; j < 4; j++) {
      if ( lane_order[j] == 0 ) {
        lane_order[j] = -1;
      }
    }

    //place++;
    // only assign 5 places, then quit
    if (place == 5) {
      break;
    }
  }